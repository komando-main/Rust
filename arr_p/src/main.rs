fn print_type_of<T>(_: T) -> String{
    std::any::type_name::<T>().to_string()
}
fn main() {
    let mut _a12:[u8;100] = [0;100];
    for i in 0.._a12.len() {
        _a12[i] += i as u8 + 1;
        println!("{}", i+1);
    }
    println!("{:?} \n{}", _a12, print_type_of(_a12));
    let a012 = _a12;
    println!("{:?} \n{}", a012, print_type_of(a012));

    let a:&[i32] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];//주소를 담는 바인드 즉 a는 참조 바인드 이다(주소담는 바인드) 어딘가에 생성된 배열의 주소를 찾아간다! 그래서 바인더는 정확한 길이를 알 수 없다!
    println!("타입 확인하기 {}", print_type_of(a));
    println!();
    let a1:[i32; 10] = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];//값을 직접 할당 한 바인드 직접적으로 길이까지 지정되었기 때문에 배열 바인드가 생성된다
    println!("타입 확인하기 {}", print_type_of(a1));
    println!();
    let a2:&[i32] = &[100, 200, 300, 400, 500, 600, 700, 800, 900, 1000];//주소를 담는 바인드 a와 동일하다
    println!("타입 확인하기 {}", print_type_of(a2));
    println!();
    let a3 = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000];//값을 직접 할당한 바인드 a1과 동일하다
    println!("타입 확인하기 {}", print_type_of(a3));
    println!();

    let p = &a1;
    let ps = &p;
    println!("p타입 확인하기 {}, &p : {:p}, ps : {:p}, &p[0] : {:p} &p와 ps 가 같다는걸 볼수있다 , {}", print_type_of(p), &p, ps, &p[0], &p[0]);//ps는 p의 주소를 담고 있다 그럼으로 &p 와 ps가 담고있는 주소값은 같다
    println!("ps[3]의 참조된 장소의 값 {}", ps[3]);//근대 프로그램상에서 이렇게 쓸일이 거이 없다고 무방하다 대부분 1번만 참조할뿐 특수한경우 아니면 다중 참조를 쓸일이 별로 없다 가독성도 떠러지며 프로그램이 무거워 진다!
    if &p == ps {
        println!("&p 와 ps는 같다 ps는 p의 주소를 담고있고 &p는 조소 자채를 보여준다 그러나 &a1 : {:p} 과는 다르다 (&p : {:p} ps : {:p})", &a1, &p, ps);
    }else{
        println!("틀리다는 군 뭔가 잘못 이해 하고있는건가?");
    }
    println!();

    let p2 = a1;
    println!("p2 타입 확인하기 {}, {:?}", print_type_of(p2), p2);//바인드를 생성함과 동시에 주소가 아닌 배열 자채를 복사하기 때문에 넘김에는 문재가 없다!
    println!();

    for i in a {// i에 각 배열의 참조값(주소)을 넘긴다 참조값 a는 참조 배열을 가저 오기 때문에 참조 바인더 이다
        println!("{}, {}, {:p}", i+1, print_type_of(i), i);
        println!("역참조 {}", *i+1);//역참조가 된다
        println!("{}", &*i+1);// i a a(배열)
    }
    println!("------------------------------");
    println!("------------------------------");
    for i in a1 {//i에 각 배열의 값을 넘긴다 여기서 a1은 쉐도잉되지 않으며 새로 생성 한 바인드 fn for(a1) a1은 인자값으로 지역변수에 새로 생성 하여 값을 복사한다 단 같은 영역(지역)인 경우 바인드 이름이 같으면 쉐도윙된다!!
        println!("{}, {}", i+1, print_type_of(i));
        // println!("역참조 {}", *i+1); //i는 값을 넘겨 받음으로 참조가 될수 없다!
        // println!("{}", &*i+1); //i는 값을 넘겨 받음으로 참조가 될수 없다!
    }
    println!("------------------------------");
    println!("------------------------------");
    for i in &*a2 {
        println!("{}, {}, {:p} 16진법으로 4비트씩 증가한다", i, print_type_of(i), i);
        println!("역참조 {}", *i+1);
        println!("{}", &*i+1);
    }
    println!("------------------------------");
    println!("------------------------------");
    for i in a2 {
        println!("{}", i+1);
        println!("역참조 {}", *i+1);
        println!("{}", &*i+1);
    }
    println!("------------------------------");
    println!("------------------------------");
    for i in a3 {//i에 각 배열의 값을 넘긴다
        println!("{}", i+1);
        // println!("역참조 {}", *i+1); //i는 값을 넘겨 받음으로 참조가 될수 없다!
        // println!("{}", &*i+1); //i는 값을 넘겨 받음으로 참조가 될수 없다!
    }
    println!("------------------------------");
    println!("------------------------------");
    for i in &a3 {//참조로 가저옴(주소) i는 주조를 담는 바인드가 됨
        println!("{}, {:p}, {}", i+1, i, print_type_of(i));//더하기는 자동으로 역참조 하여 값에 직접 더한후 새로운 바인드에 담아서 보여준다 let _ = &*i+1; 이거와 같은 상태
        println!("역참조 {}", *i+1);//위와 다르개 참조로 배열을 가저왔기때문에 역참조가 됨
        println!("{}", &*i+1);
    }
    println!("------------------------------");
}